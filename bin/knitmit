#!/usr/bin/env bash

#  Copyright 2012-2025 Stanislav Senotrusov
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Exit immediately if an unset variable is referenced
set -o nounset

# ## `fail`
#
# Terminates the script with an error message and a stack trace.
#
# ### Usage
#
# fail <message>...
#
# Arguments:
#   <message>...  Error message to display, composed from all remaining arguments.
#
# ### Examples
#
# fail "Critical failure." "Shutting down."
#
fail() {
  softfail --from-fail-wrapper "$@"
  exit 1
}

# ## `softfail`
#
# Prints an error message and stack trace without terminating the script.
#
# ### Usage
#
# softfail [OPTIONS...] <message>...
#
# Options:
#   --from-fail-wrapper   Adjusts the stack trace level when called from `fail`.
#
# Arguments:
#   <message>...  Error message to display, composed from all remaining arguments.
#
# ### Examples
#
# softfail "An unexpected error occurred."
# softfail --from-fail-wrapper "This message was passed" "through the fail function."
#
softfail() {
  local i trace_start=1 # Stack trace starts at this level

  if [ "${1:-}" = "--from-fail-wrapper" ]; then
    shift
    trace_start=2
  fi

  # Display the error message and any additional arguments to stderr
  echo "${1:-"An error occurred; refer to the stack trace for context."}" "${@:2}" >&2

  # Provide a stack trace of function calls
  for (( i=trace_start; i <= ${#BASH_LINENO[@]}-1; i++ )); do
    echo "    at ${FUNCNAME[i]} (${BASH_SOURCE[i]}:${BASH_LINENO[i-1]})" >&2
  done

  return 1
}

# ## `grep::filter`
#
# Filters out lines that match the specified patterns using `grep`.
# If no lines are found, it exits with status 0 without triggering an error.
#
# ### Usage
#
# grep::filter ARGUMENTS...
#
# Arguments:
#   ARGUMENTS...  Any valid `grep` arguments or options.
#
# ### Examples
#
# grep::filter -E "DEBUG|TRACE" file1.log file2.log
#
grep::filter () {
  grep -v "$@" || [ $? = 1 ]
}

# ## `platform::config_home`
#
# Determines the platform-specific configuration home directory.
#
# This function checks the `OSTYPE` environment variable to identify the
# operating system and then outputs the conventional path for user-specific
# application configuration files. It supports Linux, macOS, and
# Windows.
#
# ### Usage
#
# platform::config_home
#
platform::config_home() {
  # Determine configuration directory based on the operating system type
  case "${OSTYPE}" in
    linux*)
      # For Linux, use XDG_CONFIG_HOME or default to ~/.config
      echo "${XDG_CONFIG_HOME:-"${HOME}/.config"}"
      ;;
    darwin*)
      # For macOS, use ~/Library/Application Support
      echo "${HOME}/Library/Application Support"
      ;;
    msys*|cygwin*)
      # For Windows, use APPDATA
      echo "${APPDATA}"
      ;;
    *)
      # If the platform is not recognized, report a soft failure
      softfail "The operating system platform is not supported."
      return 1
      ;;
  esac
}

# ## `platform::copy_to_clipboard`
#
# Copies standard input to the system clipboard.
#
# This function attempts to use various clipboard tools (wl-copy, xclip,
# pbcopy) in a preferred order. If none of these tools are available,
# it prints the input to standard output as a fallback.
#
# ### Usage
#
# platform::copy_to_clipboard
#
platform::copy_to_clipboard() {
  # Attempt to use wl-copy (Wayland-based Linux) if available
  if command -v wl-copy >/dev/null 2>&1; then
    wl-copy || softfail "Could not access the clipboard using wl-copy." || return 1

  # Else, attempt to use xclip (X11-based Linux) if available
  elif command -v xclip >/dev/null 2>&1; then
    xclip -selection clipboard || softfail "Could not access the clipboard using xclip." || return 1

  # Else, attempt to use pbcopy (macOS) if available
  elif command -v pbcopy >/dev/null 2>&1; then
    pbcopy || softfail "Could not access the clipboard using pbcopy." || return 1
  
  # Attempt to use clip (Windows) if available
  elif command -v clip >/dev/null 2>&1; then
    clip || softfail "Could not access the clipboard using clip." || return 1

  # If no clipboard tool is found, print to standard output
  else
    echo "No clipboard tool was found. Printing to standard output instead:" >&2
    cat || softfail "Failed to read from stdin." || return 1
    
    # This is not necessarily an error since the data was displayed
    return
  fi

  # Notify the user of the successful operation
  echo "Copied to clipboard." >&2
}

# ## `shell::argument_exists`
#
# Checks if a specific argument is present in a list of provided arguments.
#
# This function iterates over a list of arguments starting from the second
# parameter and checks if any of them match the first parameter.
#
# ### Usage
#
# shell::argument_exists <argument-to-find> [<arguments-to-search-in>...]
#
# Arguments:
#   <argument-to-find>        The argument to search for in the list
#   [<arguments-to-search-in>...] A space-separated list of arguments to search within
#
# ### Examples
#
# shell::argument_exists "--help" "--help" "-v" "--config"
# shell::argument_exists "test" "run" "build" "test"
#
shell::argument_exists() {
  local arg
  # Iterate over arguments starting from the second one
  for arg in "${@:2}"; do
    # Check if the current argument matches the search target
    [ "${arg}" = "$1" ] && return 0
  done
  # If no match is found after checking all arguments, return 1 (false)
  return 1
}

# ## `shell::is_pipe_good`
#
# Checks if all components of a pipeline completed successfully.
#
# This function verifies the exit status of each command in a pipeline
# using the `PIPESTATUS` array. It returns true (0) if all commands
# succeeded, and false (1) otherwise.
#
# ### Usage
#
# shell::is_pipe_good
#
shell::is_pipe_good () {
  ! [[ "${PIPESTATUS[*]}" =~ [^[:space:]0] ]]
}

# ## `query::gemini::is_configured`
#
# Checks if the Gemini API key is configured in the environment.
#
# This function verifies the presence of the `GEMINI_API_KEY` environment variable, indicating that 
# the Gemini API is configured and ready for use.
#
# ### Usage
#
# query::gemini::is_configured
#
query::gemini::is_configured() {
  # Check if the Gemini API key is set in the environment
  [ -n "${GEMINI_API_KEY:-}" ]
}

# ## `query::gemini`
#
# Send a prompt to the Gemini language model API and retrieve the plain-text response.
#
# This function reads a prompt from `stdin`, wraps it in a JSON payload, calls the specified
# model with `curl`, then pipes the result through `jq` to pull out the generated text.
#
# ### Usage
#
# query::gemini <model-name>
#
# Arguments:
#   <model-name>  The specific model identifier.
#                 If not provided, defaults to `gemini-2.0-flash`.
#
# Available model names can be found at: https://ai.google.dev/gemini-api/docs/models
#
# ### Examples
#
# echo "Do yesternights linger in dreamworn veils?" | query::gemini gemini-2.0-flash
#
query::gemini() {
  # Assign the model name provided as an argument or use the default
  local model_name="${1:-"gemini-2.0-flash"}"

  # Declare local variables
  local input_text_json
  local response_body

  # Check if the Gemini API key is set in the environment
  if [ -z "${GEMINI_API_KEY:-}" ]; then
    echo "The GEMINI_API_KEY environment variable is not set. Please configure it before querying the model." >&2
    return 1
  fi

  # Prepare the input text as a JSON string using jq
  # This handles special characters and ensures proper formatting
  input_text_json=$(jq --exit-status --ascii-output --raw-input --slurp .) ||
    softfail "Failed to convert the input text to JSON format using 'jq'." || return 1

  # Notify the user about the model being queried
  echo "Sending request to the language model '${model_name}'..." >&2

  # Send the request to the Gemini language model API using curl
  # Capture the response for further processing and check the exit status of the curl command
  if response_body="$(curl "https://generativelanguage.googleapis.com/v1beta/models/${model_name}:generateContent?key=${GEMINI_API_KEY}" \
    --request POST \
    --header 'Content-Type: application/json' \
    --data @- <<<'{"contents": [{"role": "user", "parts":[{"text": '"${input_text_json}"'}]}]}' \
    --fail-with-body \
    --show-error \
    --silent)"
  then
    # If the request is successful, extract the plain-text content from the response
    jq --exit-status --raw-output '.candidates[].content.parts[].text' <<<"${response_body}" ||
      softfail "Failed to extract the content from the response for model '${model_name}'." || return 1
  else
    # If the request fails, inform the user
    echo "Could not retrieve a response from the language model '${model_name}'." >&2

    # Try to parse and display the specific error message returned by the API
    jq --exit-status --raw-output '.error.message' <<<"${response_body}" >&2 ||
      softfail "Failed to parse the error response from the language model '${model_name}'." || return 1

    # Return a non-zero status code to indicate failure
    return 1
  fi
}

# ## `config::get`
#
# Retrieves a value from the configuration for the specified key.
#
# This function fetches the value associated with the specified key from the JSON configuration.
# If the key is not found, it returns the provided default value instead.
#
# ### Usage
#
# config::get <key> [<default>]
#
# Arguments:
#   <key>              The configuration key to retrieve.
#   <default>          Optional default value if the key is not present.
#
# ### Examples
#
# config::get "database.host" "localhost"
#
config::get() {
  local key="$1"
  local default="${2:-"null"}"

  # Retrieve the value from the configuration JSON, or fall back to the default if not found.
  jq --raw-output "if .${key} == null then ${default} else .${key} end" <<<"${config_json}" ||
    fail "Could not retrieve the '${key}' setting from the configuration."
}

# ## `config::is_enabled`
#
# Checks if a given configuration key is enabled.
#
# This function retrieves a boolean value for the specified configuration key from the JSON configuration.
# If the key is not found, it returns the provided default value (default: "true").
#
# ### Usage
#
# config::is_enabled <key> [<default>]
#
# Arguments:
#   <key>              The configuration key to check.
#   <default>          Optional default value if the key is not present (default: "true").
#
# ### Examples
#
# config::is_enabled "feature_enabled" "false"
#
config::is_enabled() {
  local key="$1"
  local default="${2:-"true"}"
  local value

  # Retrieve the value from the configuration JSON. If not found, use the default value.
  value="$(jq --raw-output "if .${key} == null then ${default} else .${key} end" <<<"${config_json}")" ||
    fail "Could not retrieve the '${key}' setting from the configuration."

  # Return true if the value is explicitly true.
  [ "${value}" = true ]
}

# ## `config::load`
#
# Loads configuration from a JSON file or sets a default if the file is not found.
#
# This function attempts to retrieve the path to the configuration file and read its
# contents, ignoring commented lines. If the file is not found, it initializes a default
# configuration instead.
#
# ### Usage
#
# config::load
#
config::load() {
  local config_path

  # Retrieve the path to the configuration file
  config_path="$(platform::config_home)/knitmit.json" ||
    fail "Failed to determine the configuration path."

  # Check if the configuration file exists and read its contents
  if [ -f "${config_path}" ]; then
    # Load the configuration, filtering out commented lines
    config_json="$(grep::filter -E '^\s*//' "${config_path}")" ||
      fail "Failed to read the configuration file."

    return
  fi

  # Set the default configuration if the file does not exist
  config_json="$(cat <<JSON
{
  "commit_with_template": true,
  "copy_prompt": false,
  "copy_response": false,
  "interactive_prompt_limit": 139000,
  "query_language_model": true,
  "report_unavailable_commands": false,
  "model_preferences": [
    ["query::gemini", "gemini-2.5-flash-preview-05-20"],
    ["query::gemini", "gemini-2.0-flash"],
    ["query::gemini", "gemini-2.0-flash-lite"],
    ["aichat"],
    ["llm"],
    ["sgpt"]
  ]
}
JSON
    )" || fail "Failed to initialize the default configuration."
}

# ## `knitmit::commit_instructions`
#
# Print commit message formatting instructions for use with diffs.
#
# Outputs guidelines for writing clear, structured commit messages, including summary,
# body formatting, and tone principles. This content is written directly to standard output.
#
# ### Usage
#
# knitmit::commit_instructions
#
knitmit::commit_instructions() {
    cat <<'EOF' || fail "Failed to output the commit message instructions."
Based on the changes described in the diff below, write a commit message adhering to the following guidelines:

## Summary:

* The first line should be a concise summary of the commit:

  * Limit: 50 characters maximum.
  * Written in plain text - no markdown headers or special formatting.
  * Must start with a capital letter.
  * Ensure there is no trailing whitespace.

## Commit body:

* Follow the summary with a detailed explanation - only if the summary alone does not clearly convey the purpose of the changes.
* If the summary fully captures the purpose of the change, omit the body.
* If included, the body should:

  * Use Markdown, limiting formatting to lists prefixed with '*'.
  * Use quotation marks (" ") and code formatting (` `) where appropriate.
  * Keep list items compact, with no blank lines in between.
  * Begin each bullet point with a capital letter.
  * Avoid headings or additional styling.
  * Do not format URLs as markdown hyperlinks; keep them as plain URL text.
  * Ensure there is no trailing whitespace.
  * Limit each line to a maximum of 72 characters.

## Writing principles:

* Ensure clarity, conciseness, and fluency.
* Use consistent, formal terminology.
* Maintain a professional and direct tone.
* Avoid redundancy, cliches, and unnecessary embellishments.
* Avoid unnecessary elaboration or over-explaining.
* Focus on clarity and substance; avoid repetition and vague language.
* Include additional detail only when it is specific and directly relevant.

## Do not:

* Use bold, italic, or other markdown styles.
* Use overly terse, literal, or informal phrasing.

## Output format:

* Provide only the formatted commit message, without any additional remarks.
EOF
}

# ## `knitmit::display_help`
#
# Displays the help message for the script.
#
# This function prints usage instructions, a description of the script,
# and details about available commands. It determines the script's name
# dynamically for use in the help text.
#
# ### Usage
#
# knitmit::display_help
#
knitmit::display_help() {
  cat <<EOF || fail "Could not output the data."
Usage: ${BASH_SOURCE[0]##*/} [COMMAND...]

Generates a commit message suggestion based on staged Git changes by
querying the Large Language Model (LLM).

The suggested message is then used to prepare a Git commit.

Commands:

  commit-instructions
                 Displays formatting guidelines and writing standards for
                 crafting high-quality commit messages. This output may be
                 used as a template for a custom configuration file.

  copy           Generates the prompt and copies it to the system clipboard,
                 then exits. This option bypasses querying the language model,
                 allowing you to use the prompt elsewhere or review it manually.

  result         Queries the language model and copies the response to the
                 system clipboard without making a Git commit.

  short          Generates a more concise prompt. This involves using a minimal
                 diff of staged changes, which can be helpful if the default
                 prompt is too long for the language model's input limits.


  help, -h, --help
                 Displays this help message and exits.

  The commands can be specified in any order.

Requirements:

* Requires Git and must be run inside a Git repository.
* The GEMINI_API_KEY environment variable must be set to query the Gemini.
EOF
}

# ## `knitmit::main`
#
# Main script to handle configuration, prompt generation, and model querying.
#
# ### Usage
#
# knitmit::main [<arguments>...]
#
# Arguments:
#   short    Attempt to use a shorter prompt if the generated one is too long
#   copy     Skip querying the models and only copy the prompt to the clipboard
#   result   Copy the language model response to the clipboard and skip further processing
#
# ### Examples
#
# knitmit::main copy
# knitmit::main result
# knitmit::main short
# knitmit::main short copy
# knitmit::main short result
#
knitmit::main() {
  local config_json
  local interactive_prompt_limit
  local prompt
  local response

  # Show help content if a help flag is provided
  if shell::argument_exists "help" "$@" ||
    shell::argument_exists "--help" "$@" ||
    shell::argument_exists "-h" "$@"
  then
    knitmit::display_help || softfail "Failed to display help information."
    return
  fi

  # Show commit instructions if the corresponding flag is provided
  if shell::argument_exists "commit-instructions" "$@"; then
    knitmit::commit_instructions || softfail "Failed to display commit message instructions."
    return
  fi

  # Verify that the current directory is within a Git repository
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>/dev/null; then
    echo "The current directory is not part of a Git repository." >&2
    return 1
  fi

  # Confirm that changes have been staged for commit
  if git diff --cached --quiet; then
    echo "No changes have been staged for commit." >&2
    return
  fi

  # Load the configuration
  config::load || fail "Failed to load the configuration."

  # Generate the prompt using the staged changes and commit history
  # Pass all script arguments to knitmit::make_prompt for 'short' keyword detection
  prompt="$(knitmit::make_prompt "$@")" || fail "Failed to generate the prompt."

  # Check if the 'copy_prompt' configuration is enabled or if the 'copy' argument is present
  if config::is_enabled copy_prompt false || shell::argument_exists copy "$@"; then
    # Retrieve the interactive prompt limit from the configuration JSON or default to 139000
    interactive_prompt_limit="$(config::get interactive_prompt_limit 139000)" ||
      fail "Could not retrieve the interactive prompt limit from the configuration."

    # Check if the generated prompt exceeds the maximum length for interactive use
    if (( "${#prompt}" > interactive_prompt_limit )); then
      if shell::argument_exists short "$@"; then
        echo "The prompt remains too long for interactive use, even with the 'short' argument." >&2
      else
        echo "The prompt exceeds the interactive use length limit. To shorten it, use the 'short' argument:" >&2
        echo "  ${BASH_SOURCE[0]##*/} short" >&2
      fi
    fi
  fi

  # Copy the prompt to the clipboard if the 'copy_prompt' setting is enabled and no 'result' argument is provided
  if shell::argument_exists copy "$@" || { config::is_enabled copy_prompt false && ! shell::argument_exists result "$@"; }; then
    platform::copy_to_clipboard <<<"${prompt}" ||
      softfail "Could not copy the prompt to the clipboard."
  fi

  # If the 'copy' argument is present, skip querying the language model and return
  if shell::argument_exists copy "$@"; then
    echo "The 'copy' argument was provided; skipping the query to the language model." >&2
    return
  fi

  # Skip querying the language model if the configuration is disabled
  if ! config::is_enabled query_language_model; then
    echo "The 'query_language_model' setting is disabled; skipping the query to the language model." >&2
    return
  fi

  # Query available language models with the generated prompt
  response="$(knitmit::query_models "$@")" || fail "Could not query any of the available language models."

  # If the 'result' argument is provided, copy the response to the clipboard and return
  if shell::argument_exists result "$@"; then
    platform::copy_to_clipboard <<<"${response}" ||
      softfail "Could not copy the language model response to the clipboard."
    return
  fi

  # Copy the response to the clipboard if the setting is enabled
  if config::is_enabled copy_response false; then
    platform::copy_to_clipboard <<<"${response}" ||
      softfail "Could not copy the language model response to the clipboard."
  fi

  # Create a Git commit using the model's response if the setting is enabled
  if config::is_enabled commit_with_template; then
    echo "Creating a Git commit with the response as the template..." >&2
    git commit --template <(echo "${response}") ||
      fail "Failed to create a commit with the provided template."
  fi
}

# ## `knitmit::make_prompt`
#
# Generates a structured prompt for a commit message based on Git changes.
#
# This function creates a detailed prompt by analyzing staged Git changes
# (diff) and recent commit history. If the "short" keyword is provided as an
# argument, it generates a more concise prompt using a minimal diff.
#
# ### Usage
#
# knitmit::make_prompt [<keyword>]
#
# Arguments:
#   [<keyword>]  Optional keyword. If "short", generates a prompt with
#                minimal diff context. Otherwise, a more detailed diff
#                and recent commit history are included.
#
# ### Examples
#
# knitmit::make_prompt
# knitmit::make_prompt short
#
knitmit::make_prompt() {
  local commit_instructions_path context_messages=12

  # If the "short" keyword is provided, reduce the number of context messages
  if shell::argument_exists short "$@"; then
    context_messages=4
  fi

  # Retrieve the path to the commit instructions file
  commit_instructions_path="$(platform::config_home)/knitmit-commit-instructions.txt" ||
    fail "Failed to determine the configuration path."

  # Output commit instructions from file if present; fallback to built-in instructions
  if [ -f "${commit_instructions_path}" ]; then
    cat "${commit_instructions_path}" || fail "Failed to read the commit instructions file."
  else
    knitmit::commit_instructions || fail "Could not output the default commit message instructions."
  fi
  
  if git rev-parse --verify HEAD >/dev/null 2>&1; then
    cat <<'EOF' || fail "Could not output the data."

## Context

Below are the most recent commit messages for reference:

```
EOF

    # Append the last ${context_messages} commit messages.
    # Filter out "Signed-off-by" lines and remove excessive blank lines.
    # Here, `sed` is used to collapse multiple consecutive blank lines into a single blank line.
    git log -n "${context_messages}" --pretty=format:"%B" |
      grep::filter "^Signed-off-by:" |
      sed '/^$/N;/^\n$/D'

    # Verify that the pipe operation was successful
    shell::is_pipe_good || fail "Could not retrieve or process commit messages."

    echo '```'
  fi

  cat <<'EOF' || fail "Could not output the data."

## Diff

The following diff represents the changes to be included in the new commit:

```
EOF

  # Append the diff of staged changes to the prompt
  if shell::argument_exists short "$@"; then
    # Use a minimal diff if 'short' argument is provided
    git diff --diff-algorithm=minimal --no-color --cached ||
      fail "Could not generate a minimal diff."

    echo "A short prompt was generated." >&2
  else
    # Otherwise, use a more detailed histogram diff with function context
    git diff --diff-algorithm=histogram --no-color --cached --function-context -U15 ||
      fail "Could not generate a detailed diff."
  fi

  # Close the commit messages section
  echo '```'
}

# ## `knitmit::query_models`
#
# Queries a list of model preferences from a configuration JSON and attempts to retrieve a response.
# If a model command is found and responds successfully, its response is returned and the function exits.
#
# ### Usage
#
# knitmit::query_models
#
knitmit::query_models() {
  local model_list model_array model_item command_raw command_array response
  local report_line deffered_report=()

  # Extract the list of model preferences from the configuration JSON
  model_list="$(jq --exit-status --compact-output '.model_preferences[]' <<<"${config_json}")" ||
    fail "Failed to extract model preferences from the configuration."

  # Read the list of models into an array
  readarray -t model_array <<<"${model_list}" ||
    fail "Failed to read model preferences into an array."

  # Iterate over each model preference
  for model_item in "${model_array[@]}"; do
    # Convert the JSON array to a shell-compatible string representation
    command_raw="$(jq --exit-status --raw-output '. | @sh' <<<"${model_item}")" ||
      fail "Failed to process model preference item into a shell-compatible string."

    # Use eval to support newlines in arguments when expanding the array
    eval "command_array=(${command_raw})" ||
      fail "Failed to convert model preference item to a command array."

    # Verify if the command exists before attempting to run it
    if ! command -v "${command_array[0]}" >/dev/null; then
      if config::is_enabled report_unavailable_commands false; then
        echo "The command specified in the model preferences list is not available: ${command_array[*]}" >&2
      else
        deffered_report+=("The command specified in the model preferences list is not available: ${command_array[*]}")
      fi
      # Skip the rest of the loop and proceed with the next iteration
      continue
    fi

    # Check if the '<command>::is_configured' function exists in the current environment
    if declare -F "${command_array[0]}::is_configured" > /dev/null; then
      # If the function exists, invoke it to check if the command is configured properly
      if ! "${command_array[0]}::is_configured"; then
        # If the command is not configured and reporting is enabled, display a message
        if config::is_enabled report_unavailable_commands false; then
          echo "The query endpoint is listed in the model preferences list but is not configured: ${command_array[*]}" >&2
        else
          deffered_report+=("The query endpoint is listed in the model preferences list but is not configured: ${command_array[*]}")
        fi
        # Skip the rest of the loop and proceed with the next iteration
        continue
      fi
    fi
    
    # Log the outgoing request with model command details
    if ! declare -F "${command_array[0]}" > /dev/null; then
      echo "Invoking language model command: ${command_array[*]}..." >&2
    fi

    # Run the model command with the provided prompt and capture the response
    if ! response="$("${command_array[@]}" <<<"${prompt}")"; then
      echo "Model command failed with a non-zero exit status: ${command_array[*]}" >&2
      # Skip the rest of the loop and proceed with the next iteration
      continue
    fi

    # Output the response and exit the loop
    echo "${response}"
    return
  done

  # Inform the user that additional issues were reported during the model querying process
  echo "Additionally, during model querying, the following was reported:" >&2

  # Loop through the deferred report array and display each line
  for report_line in "${deffered_report[@]}"; do
    echo "${report_line}" >&2
  done

  # If no model succeeded, return with failure status
  return 1
}

# Call the main script
knitmit::main "$@"
