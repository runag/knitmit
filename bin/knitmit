#!/usr/bin/env bash

#  Copyright 2012-2025 Stanislav Senotrusov
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Exit immediately if an unset variable is referenced
set -o nounset

# ## `fail`
#
# Terminates the script with an error message and a stack trace.
#
# ### Usage
#
# fail <message>...
#
# Arguments:
#   <message>...  Error message to display, composed from all remaining arguments.
#
# ### Examples
#
# fail "Critical failure." "Shutting down."
#
fail() {
  softfail --from-fail-wrapper "$@"
  exit 1
}

# ## `softfail`
#
# Prints an error message and stack trace without terminating the script.
#
# ### Usage
#
# softfail [OPTIONS...] <message>...
#
# Options:
#   --from-fail-wrapper   Adjusts the stack trace level when called from `fail`.
#
# Arguments:
#   <message>...  Error message to display, composed from all remaining arguments.
#
# ### Examples
#
# softfail "An unexpected error occurred."
# softfail --from-fail-wrapper "This message was passed" "through the fail function."
#
softfail() {
  local i trace_start=1 # Stack trace starts at this level

  if [ "${1:-}" = "--from-fail-wrapper" ]; then
    shift
    trace_start=2
  fi

  # Display the error message and any additional arguments to stderr
  echo "${1:-"An error occurred; refer to the stack trace for context."}" "${@:2}" >&2

  # Provide a stack trace of function calls
  for (( i=trace_start; i <= ${#BASH_LINENO[@]}-1; i++ )); do
    echo "    at ${FUNCNAME[i]} (${BASH_SOURCE[i]}:${BASH_LINENO[i-1]})" >&2
  done

  return 1
}

# ## `grep::filter`
#
# Filters out lines that match the specified patterns using `grep`.
# If no lines are found, it exits with status 0 without triggering an error.
#
# ### Usage
#
# grep::filter ARGUMENTS...
#
# Arguments:
#   ARGUMENTS...  Any valid `grep` arguments or options.
#
# ### Examples
#
# grep::filter -E "DEBUG|TRACE" file1.log file2.log
#
grep::filter () {
  grep -v "$@" || [ $? = 1 ]
}

# ## `platform::config_home`
#
# Determines the platform-specific configuration home directory.
#
# This function checks the `OSTYPE` environment variable to identify the
# operating system and then outputs the conventional path for user-specific
# application configuration files. It supports Linux, macOS, and
# Windows.
#
# ### Usage
#
# platform::config_home
#
platform::config_home() {
  # Determine configuration directory based on the operating system type
  case "${OSTYPE}" in
    linux*)
      # For Linux, use XDG_CONFIG_HOME or default to ~/.config
      echo "${XDG_CONFIG_HOME:-"${HOME}/.config"}"
      ;;
    darwin*)
      # For macOS, use ~/Library/Application Support
      echo "${HOME}/Library/Application Support"
      ;;
    msys*|cygwin*)
      # For Windows, use APPDATA
      echo "${APPDATA}"
      ;;
    *)
      # If the platform is not recognized, report a soft failure
      softfail "The operating system platform is not supported."
      return 1
      ;;
  esac
}

# ## `platform::copy_to_clipboard`
#
# Copies standard input to the system clipboard.
#
# This function attempts to use various clipboard tools (wl-copy, xclip,
# pbcopy) in a preferred order. If none of these tools are available,
# it prints the input to standard output as a fallback.
#
# ### Usage
#
# platform::copy_to_clipboard
#
platform::copy_to_clipboard() {
  # Attempt to use wl-copy (Wayland-based Linux) if available
  if command -v wl-copy >/dev/null 2>&1; then
    wl-copy || softfail "Could not access the clipboard using wl-copy." || return 1

  # Else, attempt to use xclip (X11-based Linux) if available
  elif command -v xclip >/dev/null 2>&1; then
    xclip -selection clipboard || softfail "Could not access the clipboard using xclip." || return 1

  # Else, attempt to use pbcopy (macOS) if available
  elif command -v pbcopy >/dev/null 2>&1; then
    pbcopy || softfail "Could not access the clipboard using pbcopy." || return 1
  
  # Attempt to use clip (Windows) if available
  elif command -v clip >/dev/null 2>&1; then
    clip || softfail "Could not access the clipboard using clip." || return 1

  # If no clipboard tool is found, print to standard output
  else
    echo "No clipboard tool was found. Printing to standard output instead:" >&2
    cat || softfail "Failed to read from stdin." || return 1
    
    # This is not necessarily an error since the data was displayed
    return
  fi

  # Notify the user of the successful operation
  echo "Copied to clipboard." >&2
}

# ## `shell::argument_exists`
#
# Checks if a specific argument is present in a list of provided arguments.
#
# This function iterates over a list of arguments starting from the second
# parameter and checks if any of them match the first parameter.
#
# ### Usage
#
# shell::argument_exists <argument-to-find> [<arguments-to-search-in>...]
#
# Arguments:
#   <argument-to-find>        The argument to search for in the list
#   [<arguments-to-search-in>...] A space-separated list of arguments to search within
#
# ### Examples
#
# shell::argument_exists "--help" "--help" "-v" "--config"
# shell::argument_exists "test" "run" "build" "test"
#
shell::argument_exists() {
  local arg
  # Iterate over arguments starting from the second one
  for arg in "${@:2}"; do
    # Check if the current argument matches the search target
    [ "${arg}" = "$1" ] && return 0
  done
  # If no match is found after checking all arguments, return 1 (false)
  return 1
}

# ## `shell::is_pipe_good`
#
# Checks if all components of a pipeline completed successfully.
#
# This function verifies the exit status of each command in a pipeline
# using the `PIPESTATUS` array. It returns true (0) if all commands
# succeeded, and false (1) otherwise.
#
# ### Usage
#
# shell::is_pipe_good
#
shell::is_pipe_good () {
  ! [[ "${PIPESTATUS[*]}" =~ [^[:space:]0] ]]
}

# ## `query::gemini::is_configured`
#
# Checks if the Gemini API key is configured in the environment.
#
# This function verifies the presence of the `GEMINI_API_KEY` environment variable, indicating that 
# the Gemini API is configured and ready for use.
#
# ### Usage
#
# query::gemini::is_configured
#
query::gemini::is_configured() {
  # Check if the Gemini API key is set in the environment
  [ -n "${GEMINI_API_KEY:-}" ]
}

# ## `query::gemini`
#
# Send a prompt to the Gemini language model API and retrieve the plain-text response.
#
# This function reads a prompt from `stdin`, wraps it in a JSON payload, calls the specified
# model with `curl`, then pipes the result through `jq` to pull out the generated text.
#
# ### Usage
#
# query::gemini <model-name>
#
# Arguments:
#   <model-name>  The specific model identifier.
#                 If not provided, defaults to `gemini-2.0-flash`.
#
# Available model names can be found at: https://ai.google.dev/gemini-api/docs/models
#
# ### Examples
#
# echo "Do yesternights linger in dreamworn veils?" | query::gemini gemini-2.0-flash
#
query::gemini() {
  # Assign the model name provided as an argument or use the default
  local model_name="${1:-"gemini-2.0-flash"}"

  # Declare local variables
  local input_text_json
  local response_body

  # Check if the Gemini API key is set in the environment
  if [ -z "${GEMINI_API_KEY:-}" ]; then
    echo "The GEMINI_API_KEY environment variable is not set. Please configure it before querying the model." >&2
    return 1
  fi

  # Prepare the input text as a JSON string using jq.
  # This handles special characters and ensures proper formatting.
  input_text_json=$(jq --exit-status --ascii-output --raw-input --slurp .) ||
    softfail "Failed to convert the input text to JSON format using 'jq'." || return 1

  # Notify the user about the model being queried
  echo "Sending request to the language model '${model_name}'..." >&2

  # Send the request to the Gemini language model API using curl.
  # Capture the response for further processing and check the exit status of the curl command.
  if response_body="$(curl "https://generativelanguage.googleapis.com/v1beta/models/${model_name}:generateContent?key=${GEMINI_API_KEY}" \
    --request POST \
    --header 'Content-Type: application/json' \
    --data @- <<<'{"contents": [{"role": "user", "parts":[{"text": '"${input_text_json}"'}]}]}' \
    --fail-with-body \
    --show-error \
    --silent)"
  then
    # If the request is successful, extract the plain-text content from the response
    jq --exit-status --raw-output '.candidates[].content.parts[].text' <<<"${response_body}" ||
      softfail "Failed to extract the content from the response for model '${model_name}'." || return 1
  else
    # If the request fails, inform the user
    echo "Could not retrieve a response from the language model '${model_name}'." >&2

    # Try to parse and display the specific error message returned by the API
    jq --exit-status --raw-output '.error.message' <<<"${response_body}" >&2 ||
      softfail "Failed to parse the error response from the language model '${model_name}'." || return 1

    # Return a non-zero status code to indicate failure
    return 1
  fi
}

# ## `knitmit::commit_instructions`
#
# Print commit message formatting instructions for use with diffs.
#
# Outputs guidelines for writing clear, structured commit messages, including summary,
# body formatting, and tone principles. This content is written directly to standard output.
#
# ### Usage
#
# knitmit::commit_instructions
#
knitmit::commit_instructions() {
    cat <<'EOF' || fail "Failed to output the commit message instructions."
You are an AI assistant tasked with generating a Commit Message.

Generate a Commit Message based on the provided Diff and Recent Commit History. Follow these rules precisely:

1. Commit Message Requirements:

* The Commit Message MUST clearly state the purpose of the change derived from the provided Diff.
* It MUST consist of a Summary Line followed by an optional Commit Body.
* If a Commit Body is present, it MUST be separated from the Summary Line by exactly one blank line.
* The Commit Body IS REQUIRED if the change is too complex to be fully explained in the Summary Line.

2. Summary Line:

* MUST be a single sentence, a concise summary of the change.
* MUST NOT exceed 50 characters in length.
* MUST start with a capital letter.
* MUST be plain text only (no Markdown formatting or styling).
* MUST NOT contain trailing whitespace.

3. Commit Body:

If a Commit Body is included, it MUST adhere to the following:

* Be formatted as a Markdown list.
* Have NO blank lines between list items.
* Each list item MUST start with a capital letter.
* Each list item MUST use `*` as the bullet character.
* Each list item MUST have exactly one space between the `*` and the list item text (e.g., `* List item`).
* Indentation for nesting:
  * Top-level list items (the start of the Commit Body) MUST have zero leading spaces (no indentation before the `*`).
  * Each subsequent nesting level MUST be indented by exactly two additional spaces before the `*` character.
  * Example showing top-level and one level of nesting:
    `* Top-level item`
    `  * Nested item`
* Wrap all code elements, identifiers, and literal values in backticks (e.g., `variableName`, `function()`, `true`).
* Use plain URLs only (e.g., `http://example.com`), not Markdown-style links (e.g., `[Example](http://example.com)`).
* All lines within the Commit Body MUST NOT exceed 72 characters. Lines that would exceed this limit MUST be wrapped to fit.
* Each line MUST NOT contain trailing whitespace.

4. Language and General Formatting (applies to the entire commit message):

* Use clear, concise, and consistent professional language.
* Avoid vague terms, filler words, or redundancy.
* Use ASCII for English text. Use Unicode ONLY for non-English text or quoted non-ASCII code.
* DO NOT use bold, italic, or other Markdown styling (except for backticks and list markers as specified for the commit body).

5. Input Context:

* Utilize the provided Recent Commit History as context to better understand the provided Diff and maintain consistency.
* The primary source for the commit message content is the Diff.

6. Output Format:

* Return ONLY the formatted commit message.
* DO NOT include any commentary, headings, or explanatory text before or after the commit message.
EOF
}

# ## `knitmit::make_prompt`
#
# Generates a structured prompt for a commit message based on Git changes.
#
# This function creates a detailed prompt by analyzing staged Git changes
# (diff) and recent commit history. If the "short" keyword is provided as an
# argument, it generates a more concise prompt using a minimal diff.
#
# ### Usage
#
# knitmit::make_prompt [<keyword>]
#
# Arguments:
#   [<keyword>]  Optional keyword. If "short", generates a prompt with
#                minimal diff context. Otherwise, a more detailed diff
#                and recent commit history are included.
#
# ### Examples
#
# knitmit::make_prompt
# knitmit::make_prompt short
#
knitmit::make_prompt() {
  local commit_instructions_path context_messages=12

  # If the "short" keyword is provided, reduce the number of context messages
  if shell::argument_exists short "$@"; then
    context_messages=4
  fi

  # Retrieve the path to the commit instructions file
  commit_instructions_path="$(platform::config_home)/knitmit-commit-instructions.txt" ||
    fail "Failed to determine the configuration path."

  # Output commit instructions from file if present; fallback to built-in instructions
  if [ -f "${commit_instructions_path}" ]; then
    cat "${commit_instructions_path}" || fail "Failed to read the commit instructions file."
  else
    knitmit::commit_instructions || fail "Could not output the default commit message instructions."
  fi
  
  # Check if the current directory is a Git repository with at least one commit
  if git rev-parse --verify HEAD >/dev/null 2>&1; then
    echo ""
    echo "Recent Commit History:"
    echo ""
    echo "--- BEGIN RECENT COMMIT HISTORY ---"

    # Append the last ${context_messages} commit messages.
    # Filter out "Signed-off-by" lines and remove excessive blank lines.
    # Here, `sed` is used to collapse multiple consecutive blank lines into a single blank line.
    git log -n "${context_messages}" --pretty=format:"%B" |
      grep::filter "^Signed-off-by:" |
      sed '/^$/N;/^\n$/D'

    # Verify that the pipe operation was successful
    shell::is_pipe_good || fail "Could not retrieve or process commit messages."

    # Close the commit history section
    echo "--- END RECENT COMMIT HISTORY ---"
  fi

  echo ""
  echo "Diff:"
  echo ""
  echo "--- BEGIN DIFF ---"

  # Append the diff of staged changes to the prompt
  if shell::argument_exists short "$@"; then
    # Use a minimal diff if 'short' argument is provided
    git diff --diff-algorithm=minimal --no-color --cached ||
      fail "Could not generate a minimal diff."

    echo "A short prompt was generated." >&2
  else
    # Otherwise, use a more detailed histogram diff with function context
    git diff --diff-algorithm=histogram --no-color --cached --function-context -U15 ||
      fail "Could not generate a detailed diff."
  fi

  # Close the diff section
  echo "--- END DIFF ---"
}

# ## `knitmit::query_models`
#
# Queries a list of model preferences from a configuration JSON and attempts to retrieve a response.
# If a model command is found and responds successfully, its response is returned and the function exits.
#
# ### Usage
#
# knitmit::query_models
#
knitmit::query_models() {
  local model_list model_array model_item command_raw command_array response
  local report_line deffered_report=()

  # Extract the list of model preferences from the configuration JSON
  model_list="$(jq --exit-status --compact-output '.model_preferences[]' <<<"${CONFIG_JSON}")" ||
    fail "Failed to extract model preferences from the configuration."

  # Read the list of models into an array
  readarray -t model_array <<<"${model_list}" ||
    fail "Failed to read model preferences into an array."

  # Iterate over each model preference
  for model_item in "${model_array[@]}"; do
    # Convert the JSON array to a shell-compatible string representation
    command_raw="$(jq --exit-status --raw-output '. | @sh' <<<"${model_item}")" ||
      fail "Failed to process model preference item into a shell-compatible string."

    # Use eval to support newlines in arguments when expanding the array
    eval "command_array=(${command_raw})" ||
      fail "Failed to convert model preference item to a command array."

    # Verify if the command exists before attempting to run it
    if ! command -v "${command_array[0]}" >/dev/null; then
      if config::is_enabled report_unavailable_commands; then
        echo "The command specified in the model preferences list is not available: ${command_array[*]}" >&2
      else
        deffered_report+=("The command specified in the model preferences list is not available: ${command_array[*]}")
      fi
      # Skip the rest of the loop and proceed with the next iteration
      continue
    fi

    # Check if the '<command>::is_configured' function exists in the current environment
    if declare -F "${command_array[0]}::is_configured" > /dev/null; then
      # If the function exists, invoke it to check if the command is configured properly
      if ! "${command_array[0]}::is_configured"; then
        # If the command is not configured and reporting is enabled, display a message
        if config::is_enabled report_unavailable_commands; then
          echo "The query endpoint is listed in the model preferences list but is not configured: ${command_array[*]}" >&2
        else
          deffered_report+=("The query endpoint is listed in the model preferences list but is not configured: ${command_array[*]}")
        fi
        # Skip the rest of the loop and proceed with the next iteration
        continue
      fi
    fi
    
    # Log the outgoing request with model command details
    if ! declare -F "${command_array[0]}" > /dev/null; then
      echo "Invoking language model command: ${command_array[*]}..." >&2
    fi

    # Run the model command with the provided prompt and capture the response
    if ! response="$("${command_array[@]}" <<<"${prompt}")"; then
      echo "Model command failed with a non-zero exit status: ${command_array[*]}" >&2
      # Skip the rest of the loop and proceed with the next iteration
      continue
    fi

    # Output the response and exit the loop
    echo "${response}"
    return
  done

  if [ ${#deffered_report[@]} -gt 0 ]; then
    # Inform the user that additional issues were reported during the model querying process
    echo "During model querying, the following was reported:" >&2

    # Loop through the deferred report array and display each line
    for report_line in "${deffered_report[@]}"; do
      echo "${report_line}" >&2
    done
  fi

  # If no model succeeded, return with failure status
  return 1
}

# ## `config::get`
#
# Retrieves a value from the configuration for the specified key.
#
# This function fetches the value associated with the specified key from the JSON configuration.
#
# ### Usage
#
# config::get <key>
#
# Arguments:
#   <key>  The configuration key to retrieve.
#
# ### Examples
#
# config::get "some_value"
#
config::get() {
  local key="$1"

  # Retrieve the value from the configuration JSON
  jq --raw-output ".${key}" <<<"${CONFIG_JSON}" ||
    fail "Could not retrieve the '${key}' setting from the configuration."
}

# ## `config::is_enabled`
#
# Checks if a given configuration key is enabled.
#
# This function retrieves a boolean value for the specified configuration key from the JSON configuration.
#
# ### Usage
#
# config::is_enabled <key>
#
# Arguments:
#   <key>  The configuration key to check.
#
# ### Examples
#
# config::is_enabled "feature_enabled"
#
config::is_enabled() {
  local key="$1"
  local value

  # Retrieve the value from the configuration JSON. If not found, use the default value
  value="$(jq --raw-output ".${key}" <<<"${CONFIG_JSON}")" ||
    fail "Could not retrieve the '${key}' setting from the configuration."

  # Return true if the value is explicitly true
  [ "${value}" = true ]
}

# ## `config::load`
#
# Load configuration from a JSON file or fall back to default settings.
#
# This function attempts to locate and read the configuration file from the platform's config
# directory. If the file is not present, it falls back to using the built-in default configuration.
# When a file is present, it merges its contents with the default configuration, filtering out
# commented lines for clean parsing.
#
# ### Usage
#
# config::load
#
config::load() {
  local default_config config_path user_config

  # Initialize default configuration content
  default_config="$(config::default)" ||
    fail "Failed to initialize the default configuration."

  # Determine the expected path to the configuration file
  config_path="$(platform::config_home)/knitmit.json" ||
    fail "Failed to determine the configuration path."

  # Check if the config file exists
  if [ -f "${config_path}" ]; then
    # Filter out lines that are commented and store clean user configuration
    user_config="$(grep::filter -E '^\s*//' "${config_path}")" ||
      fail "Failed to read the configuration file."

    # Merge default configuration with user-defined overrides
    jq --argjson default_config "${default_config}" \
       --argjson user_config "${user_config}" \
       '$default_config * $user_config' <<<'{}' ||
      fail "Failed to merge default and user configuration."
  else
    # If config file is not found, output default configuration
    echo "${default_config}"
  fi
}

# ## `config::default`
#
# Print the default configuration in JSON format.
#
# Outputs a static JSON configuration that defines default values for user options such as
# prompt behavior, model preferences, and command reporting. This function is used as a baseline
# setup for the script's behavior and may be redirected or parsed elsewhere.
#
# ### Usage
#
# config::default
#
config::default() {
  # Print the default configuration in JSON format
  cat <<JSON || fail "Failed to print the default configuration."
{
  "commit_with_template": true,
  "copy_prompt": false,
  "copy_response": false,
  "interactive_prompt_limit": 139000,
  "query_language_model": true,
  "report_unavailable_commands": false,
  "model_preferences": [
    ["query::gemini", "gemini-2.5-flash-preview-05-20"],
    ["query::gemini", "gemini-2.0-flash"],
    ["query::gemini", "gemini-2.0-flash-lite"],
    ["aichat"],
    ["llm"],
    ["sgpt"]
  ]
}
JSON
}

# ## `knitmit::main`
#
# Main script to handle configuration, prompt generation, and model querying.
#
# ### Usage
#
# knitmit::main [<arguments>...]
#
# Arguments:
#   short    Attempt to use a shorter prompt if the generated one is too long
#   copy     Skip querying the models and only copy the prompt to the clipboard
#   result   Copy the language model response to the clipboard and skip further processing
#
# ### Examples
#
# knitmit::main copy
# knitmit::main result
# knitmit::main short
# knitmit::main short copy
# knitmit::main short result
#
knitmit::main() {
  local CONFIG_JSON
  local interactive_prompt_limit
  local prompt
  local response

  # Show help content if a help flag is provided
  if shell::argument_exists "help" "$@" ||
    shell::argument_exists "--help" "$@" ||
    shell::argument_exists "-h" "$@"
  then
    knitmit::display_help || softfail "Failed to display help information."
    return
  fi

  # Show commit instructions if the corresponding flag is provided
  if shell::argument_exists "commit-instructions" "$@"; then
    knitmit::commit_instructions || softfail "Failed to display commit message instructions."
    return
  fi

  # Verify that the current directory is within a Git repository
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>/dev/null; then
    echo "The current directory is not part of a Git repository." >&2
    return 1
  fi

  # Confirm that changes have been staged for commit
  if git diff --cached --quiet; then
    echo "No changes have been staged for commit." >&2
    return
  fi

  # Load the configuration
  CONFIG_JSON="$(config::load)" || fail "Failed to load the configuration."

  # Generate the prompt using the staged changes and commit history.
  # Pass all script arguments to knitmit::make_prompt for 'short' keyword detection.
  prompt="$(knitmit::make_prompt "$@")" || fail "Failed to generate the prompt."

  # Check if the 'copy_prompt' configuration is enabled or if the 'copy' argument is present
  if config::is_enabled copy_prompt || shell::argument_exists copy "$@"; then
    # Retrieve the interactive prompt limit from the configuration JSON
    interactive_prompt_limit="$(config::get interactive_prompt_limit)" ||
      fail "Could not retrieve the interactive prompt limit from the configuration."

    # Check if the generated prompt exceeds the maximum length for interactive use
    if (( "${#prompt}" > interactive_prompt_limit )); then
      if shell::argument_exists short "$@"; then
        echo "The prompt remains too long for interactive use, even with the 'short' argument." >&2
      else
        echo "The prompt exceeds the interactive use length limit. To shorten it, use the 'short' argument:" >&2
        echo "  ${BASH_SOURCE[0]##*/} short" >&2
      fi
    fi
  fi

  # Copy the prompt to the clipboard if the 'copy' argument is provided, or if
  # the 'copy_prompt' setting is enabled, there is no 'result' argument, and the output is a terminal.
  if shell::argument_exists copy "$@" || { config::is_enabled copy_prompt && ! shell::argument_exists result "$@" && [ -t 1 ]; }; then
    platform::copy_to_clipboard <<<"${prompt}" ||
      softfail "Could not copy the prompt to the clipboard."
  fi

  # If the 'copy' argument is present, skip querying the language model and return
  if shell::argument_exists copy "$@"; then
    echo "The 'copy' argument was provided; skipping the query to the language model." >&2
    return
  fi

  # Skip querying the language model if the configuration is disabled
  if ! config::is_enabled query_language_model; then
    echo "The 'query_language_model' setting is disabled; skipping the query to the language model." >&2
    return
  fi

  # Query available language models with the generated prompt
  response="$(knitmit::query_models "$@")" || fail "Could not query any of the available language models."

  # If the 'result' argument is provided and the output is a terminal, copy the response to the clipboard and return
  if shell::argument_exists result "$@" && [ -t 1 ]; then
    platform::copy_to_clipboard <<<"${response}" ||
      softfail "Could not copy the language model response to the clipboard."
    return
  fi

  # If standard output is not a terminal, output the response and return
  if ! [ -t 1 ]; then
    echo "${response}"
    return
  fi

  # Copy the response to the clipboard if the setting is enabled
  if config::is_enabled copy_response; then
    platform::copy_to_clipboard <<<"${response}" ||
      softfail "Could not copy the language model response to the clipboard."
  fi

  # Create a Git commit using the model's response if the setting is enabled
  if config::is_enabled commit_with_template; then
    echo "Creating a Git commit with the response as the template..." >&2
    git commit --template <(echo "${response}") ||
      fail "Failed to create a commit with the provided template."
  else
    # Otherwise, just output the response without creating a Git commit
    echo "${response}"
    return
  fi
}

# ## `knitmit::display_help`
#
# Displays the help message for the script.
#
# This function prints usage instructions, a description of the script,
# and details about available commands. It determines the script's name
# dynamically for use in the help text.
#
# ### Usage
#
# knitmit::display_help
#
knitmit::display_help() {
  cat <<EOF || fail "Could not output the data."
Usage: ${BASH_SOURCE[0]##*/} [COMMAND...]

Generates a commit message suggestion based on staged Git changes by
querying the Large Language Model (LLM).

The suggested message is then used to prepare a Git commit.

Commands:

  commit-instructions
                 Displays formatting guidelines and writing standards for
                 crafting high-quality commit messages. This output may be
                 used as a template for a custom configuration file.

  copy           Generates the prompt and copies it to the system clipboard,
                 then exits. This option bypasses querying the language model,
                 allowing you to use the prompt elsewhere or review it manually.

  result         Queries the language model and copies the response to the
                 system clipboard without making a Git commit.

  short          Generates a more concise prompt. This involves using a minimal
                 diff of staged changes, which can be helpful if the default
                 prompt is too long for the language model's input limits.


  help, -h, --help
                 Displays this help message and exits.

  The commands can be specified in any order.

Requirements:

* Requires Git and must be run inside a Git repository.
* The GEMINI_API_KEY environment variable must be set to query the Gemini.
EOF
}

# Call the main script
knitmit::main "$@"
